# create colour paletter
library(RColorBrewer)
colorRampPalette(c("blue", "red"))( 4)
blockModelFunc <- function(networkData, nClusters=NULL) {
# transform input list into network list
networkList <- networkDynamic(network.list=networkData)
# remove the necessary observations that are exempt from each fold
delete.vertices(networkList, (1:dim(nigeriaAdjMat)[1])[-cvFolds[[i]]])
# create clusters from structural equivalence
equivNetClusters <- equiv.clust(networkList)
# perform blockmodel
blockModel <- blockmodel(networkList, equivNetClusters, k=nClusters)
# take info that pertains to which block actors are placed in
groupMembership <- blockModel$block.membership[blockModel$order.vec]
# assign the block group values from the model back in the networkList
networkList%v%"member" <- groupMembership
}
crossValidateFunc <- function(networkData, nFolds=NULL, nClusters=NULL) {
# set seed for reproducibility
set.seed(5)
# createFolds function from caret package
# argument gives a list of the indicies in each fold
# from the groups that comprise all possible conflicts
# return training data
cvFolds <- createFolds(y = unique(nigeria$sender),
k=nFolds, returnTrain = T)
# create empty vectors to fill w/ goodness-of-fit stats
# from TERGMS (AUC (ROC) and AUC (PR))
# ROC and PR curves can be used to compare different model specifications,
# also for within-sample goodness-of-fit
AUC_ROC <- NULL; AUC_PR <- NULL
# iterate over folds
for (i in 1:nFolds) {
blockModelFunc(nigeriaAdjMatNetworkList, nClusters=NULL)
# now run the out-of-sample prediction with TERGMs
outSampleTERGM <- btergm(as.network.networkDynamic(networkList) ~ edges +
gwesp(.5, fixed = TRUE) + nodecov("member"))
# now, simulate 100 networks from the model w/ rocpr
# to condense the performance into a single measure, the area under
# the curve (AUC) can be reported for both curves.
goodFitStats <- gof(outSampleTERGM, statistics = rocpr, nsim = 100)
# for each iteration/fold, remove and store statistics to existing list
AUC_ROC <- c(AUC_ROC, goodFitStats$`Tie prediction`$auc.roc)
AUC_PR <- c(AUC_PR, goodFitStats$`Tie prediction`$auc.pr)
}
# return the mean of each statistic pooled over the folds
return(list(avgAUC_ROC=mean(AUC_ROC), avgAUC_PR=mean(AUC_PR)))
}
crossValidateFunc(nigeriaAdjMatNetworkList, nFolds=10, nClusters=2)
crossValidateFunc <- function(networkData, nFolds=NULL, nClusters=NULL) {
# set seed for reproducibility
set.seed(5)
# createFolds function from caret package
# argument gives a list of the indicies in each fold
# from the groups that comprise all possible conflicts
# return training data
cvFolds <- createFolds(y = unique(nigeria$sender),
k=nFolds, returnTrain = T)
blockModelFunc <- function(networkData, nClusters=NULL) {
# transform input list into network list
networkList <- networkDynamic(network.list=networkData)
# remove the necessary observations that are exempt from each fold
delete.vertices(networkList, (1:dim(nigeriaAdjMat)[1])[-cvFolds[[i]]])
# create clusters from structural equivalence
equivNetClusters <- equiv.clust(networkList)
# perform blockmodel
blockModel <- blockmodel(networkList, equivNetClusters, k=nClusters)
# take info that pertains to which block actors are placed in
groupMembership <- blockModel$block.membership[blockModel$order.vec]
# assign the block group values from the model back in the networkList
networkList%v%"member" <- groupMembership
}
# create empty vectors to fill w/ goodness-of-fit stats
# from TERGMS (AUC (ROC) and AUC (PR))
# ROC and PR curves can be used to compare different model specifications,
# also for within-sample goodness-of-fit
AUC_ROC <- NULL; AUC_PR <- NULL
# iterate over folds
for (i in 1:nFolds) {
blockModelFunc(nigeriaAdjMatNetworkList, nClusters=NULL)
# now run the out-of-sample prediction with TERGMs
outSampleTERGM <- btergm(as.network.networkDynamic(networkList) ~ edges +
gwesp(.5, fixed = TRUE) + nodecov("member"))
# now, simulate 100 networks from the model w/ rocpr
# to condense the performance into a single measure, the area under
# the curve (AUC) can be reported for both curves.
goodFitStats <- gof(outSampleTERGM, statistics = rocpr, nsim = 100)
# for each iteration/fold, remove and store statistics to existing list
AUC_ROC <- c(AUC_ROC, goodFitStats$`Tie prediction`$auc.roc)
AUC_PR <- c(AUC_PR, goodFitStats$`Tie prediction`$auc.pr)
}
# return the mean of each statistic pooled over the folds
return(list(avgAUC_ROC=mean(AUC_ROC), avgAUC_PR=mean(AUC_PR)))
}
crossValidateFunc <- function(networkData, nFolds=NULL, nClusters=NULL) {
# set seed for reproducibility
set.seed(5)
# createFolds function from caret package
# argument gives a list of the indicies in each fold
# from the groups that comprise all possible conflicts
# return training data
cvFolds <- createFolds(y = unique(nigeria$sender),
k=nFolds, returnTrain = T)
blockModelFunc <- function(networkData, nClusters=NULL) {
# transform input list into network list
networkList <- networkDynamic(network.list=networkData)
# remove the necessary observations that are exempt from each fold
delete.vertices(networkList, (1:dim(nigeriaAdjMat)[1])[-cvFolds[[i]]])
# create clusters from structural equivalence
equivNetClusters <- equiv.clust(networkList)
# perform blockmodel
blockModel <- blockmodel(networkList, equivNetClusters, k=nClusters)
# take info that pertains to which block actors are placed in
groupMembership <- blockModel$block.membership[blockModel$order.vec]
# assign the block group values from the model back in the networkList
networkList%v%"member" <- groupMembership
}
# create empty vectors to fill w/ goodness-of-fit stats
# from TERGMS (AUC (ROC) and AUC (PR))
# ROC and PR curves can be used to compare different model specifications,
# also for within-sample goodness-of-fit
AUC_ROC <- NULL; AUC_PR <- NULL
# iterate over folds
for (i in 1:nFolds) {
blockModelFunc(nigeriaAdjMatNetworkList, nClusters=NULL)
# now run the out-of-sample prediction with TERGMs
outSampleTERGM <- btergm(as.network.networkDynamic(networkList) ~ edges +
gwesp(.5, fixed = TRUE) + nodecov("member"))
# now, simulate 100 networks from the model w/ rocpr
# to condense the performance into a single measure, the area under
# the curve (AUC) can be reported for both curves.
goodFitStats <- gof(outSampleTERGM, statistics = rocpr, nsim = 100)
# for each iteration/fold, remove and store statistics to existing list
AUC_ROC <- c(AUC_ROC, goodFitStats$`Tie prediction`$auc.roc)
AUC_PR <- c(AUC_PR, goodFitStats$`Tie prediction`$auc.pr)
}
# return the mean of each statistic pooled over the folds
return(list(avgAUC_ROC=mean(AUC_ROC), avgAUC_PR=mean(AUC_PR)))
}
crossValidateFunc(nigeriaAdjMatNetworkList, nFolds=10, nClusters=2)
# show table of goodness-of-fit statistics
print(data.frame(k=2:10, AUC_ROC=AUC_ROCvec, AUC_PR=AUC_PRvec))
# (c) could go w/ either 3 or 9 clusters
# we'll do 3
# re-create the network object
networkList <- networkDynamic(network.list=nigeriaAdjMatNetworkList)
# run the block model w/ 3 clusters
bestKblockModel <- blockmodel(networkList,
equiv.clust(networkList),
k=3)
# re-assign the groupings from the block model into the network object
bestGrouping <- bestKblockModel$block.membership[bestKblockModel$order.vec]
networkList%v%"member" <- bestGrouping
# now for the plot
# create colour paletter
library(RColorBrewer)
networkList %v% "col" <- brewer.pal(3, "Dark2")[networkList %v% "member"]
plot(networkList, label = labels, label.cex=0.5, mode="circle", vertex.cex=log(deg_all)+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(deg_all)+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(degree(networkList))+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
# generate plot
pdf("figure1.pdf")
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(degree(networkList))+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
dev.off()
# (c) since we want these values to be higher
# we'll do 7 clusters
# re-create the network object
networkList <- networkDynamic(network.list=nigeriaAdjMatNetworkList)
# run the block model w/ 7 clusters
bestKblockModel <- blockmodel(networkList,
equiv.clust(networkList),
k=7)
# re-assign the groupings from the block model into the network object
bestGrouping <- bestKblockModel$block.membership[bestKblockModel$order.vec]
networkList%v%"member" <- bestGrouping
networkList %v% "col" <- brewer.pal(7, "Dark2")[networkList %v% "member"]
# generate plot
pdf("figure1.pdf")
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(degree(networkList))+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
dev.off()
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(degree(networkList))+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
# set working directory to Git location
setwd('/Users/jeffziegler/Documents/Git/network2018_hw1/')
# load data
load("nigeria.rda")
# generate plot
pdf("figure1.pdf")
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(degree(networkList))+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
dev.off()
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(degree(networkList))+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
dev.off()
# generate plot
pdf("figure1.pdf")
plot(networkList, label = network.vertex.names(networkList), label.cex=0.5,
mode="circle", vertex.cex=log(degree(networkList))+1,
label.col="black", vertex.col="col", vertex.border="col", edge.col="black")
dev.off()
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(nigeriaAdjMatNetworkList ~ edges + idegree1.5 + mutual +
triangle + gwidegree(decay = 0.5, fixed = TRUE))
nigeriaAdjMatNetworkList
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(nigeriaAdjMatYearlyList ~ edges + idegree1.5 + mutual +
triangle + gwidegree(decay = 0.5, fixed = TRUE))
nigeriaAdjMatYearlyList[[1]]
networkList
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(networkList[[1]] ~ edges + idegree1.5 + mutual +
triangle + gwidegree(decay = 0.5, fixed = TRUE))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(networkList[[1]] ~ edges + idegree1.5 + mutual + triangle + gwidegree(decay = 0.5, fixed = TRUE))
networkList[[1]]
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(nigeriaAdjMatNetworkList[[1]] ~ edges + idegree1.5 + mutual + triangle + gwidegree(decay = 0.5, fixed = TRUE))
# (b) results
summary(m)
# (b) results
summary(ERGMmodel)
# (c) check for convergence
mcmc.diagnostics(ERGMmodel)
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(nigeriaAdjMatNetworkList ~ edges + idegree1.5 + mutual + triangle + gwidegree(decay = 0.5, fixed = TRUE))
nigeriaAdjMatNetworkList
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 + mutual + triangle + gwidegree(decay = 0.5, fixed = TRUE))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 + mutual +
triangle)
?ergm
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(MCMC.samplesize=10000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(MCMC.samplesize=10000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=4, MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=5, MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=6, MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=1, MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=2, MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=10, MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(int=c(2,2,2,2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=c(2,2,2,2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
as.network.matrix(nigeriaAdjMatTotalMatrix)
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=c(-2,2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges + idegree1.5 +
mutual + triangle, control=control.ergm(init=c(-2,2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=2000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=2000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=2000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (idegree1.5: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=2000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=2000, SAN.maxit=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=2000, SAN.maxit=2000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=3000, SAN.maxit=1000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=3000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=5000,
MCMLE.Hummel.miss.sample=5000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=10000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=1000,
MCMLE.Hummel.miss.sample=5000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=10000,
MCMLE.Hummel.miss.sample=10000, MCMC.burnin=5000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.networkDynamic(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=10000,
MCMLE.Hummel.miss.sample=10000, MCMC.burnin=5000))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.networkDynamic(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=5000,
MCMLE.Hummel.miss.sample=5000, MCMC.burnin=1000, MCMLE.steplength.margin=0))
library(statnet)
str(nigeriaAdjMatTotalMatrix)
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle, control=control.ergm(init=c(-2,2,-2), MCMC.samplesize=5000,
MCMLE.Hummel.miss.sample=5000, MCMC.burnin=1000, MCMLE.steplength.margin=0))
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle)
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix[[1]]) ~ edges +
mutual + triangle)
as.network.matrix(nigeriaAdjMatTotalMatrix[[1]])
nigeriaAdjMatTotalMatrix[[1]]
# (a) Run a cross-sectional ERGM on the Nigerian conflict network
# H1: First order (edges: Some actors (like the gov't) are engaged in conflict a lot)
# H2: Second order (mutual: Reciprocity should be high)
# H3: Third order (triangle: Allies exist in the network (police, military), transitivity might be high?)
# include geometrically weighted terms
diag(nigeriaAdjMatTotalMatrix) <- NA
ERGMmodel <- ergm(as.network.matrix(nigeriaAdjMatTotalMatrix) ~ edges +
mutual + triangle)
as.network.matrix(nigeriaAdjMatTotalMatrix)
nigeriaAdjMatTotalMatrix
